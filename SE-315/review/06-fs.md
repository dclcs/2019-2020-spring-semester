# OS Review

## File System

### inode 文件系统

![image-20200628182057414](06-fs.assets/image-20200628182057414.png)

#### inode 是啥？

一个 `inode` 中包含直接指针（直接指向数据块的）12 个，一级、二级、三级间接指针各一个。

#### 目录

内容是一组目录项（记录 inode、子文件（或目录）名）的特殊文件。文件名/目录名存放在其上层目录中。

> 因此，`/` 是没有名字的。

#### 软链接（符号链接）

这个文件的内容是「一个路径」。查找的时候会「跳」到目标路径去找。

#### 硬链接

并不是一个「文件」。只不过是同一个 inode 出现在多个目录项之中。

#### 「区段」的优化

对于大文件来说，采用 inode 的形式组织就太散了，不方便读取。

如果我们能找到一块连续区段保存文件，并把起始和结束地址存下来，就能减少元数据的数量啦。

### FAT 文件系统

![image-20200628185310728](06-fs.assets/image-20200628185310728.png)

简单粗暴…

### VFS

考虑到 OS 中可能有许多种不同的文件系统，Linux 提出了一套高于文件系统的抽象（Interface），使得不同的文件系统可以协同工作。

#### Root

注意，不同的文件系统都有相同的根结点（对于 Ext4 文件系统而言，是 `/`）。而 VFS 树的根结点只能有一个。

因此实际上系统在构造 VFS 的时候，会选择一个文件系统作为根结点，而其他的文件系统则会被挂载在特殊的子节点处（如，`/dev/`）。遍历文件树时，假如遇到了这个特殊的挂载点，就切换文件系统。

### Flash FS

专门用于闪存盘的文件系统。

闪存盘最大的问题：每个块都有写入/擦除的次数寿命。因此不可以把高频读写的数据过于集中在某一位置。另外，尽可能少写数据。

#### FTL 层

Flash Translation Layer，所谓「逻辑地址」到「物理地址」的转换层。也就是，逻辑地址无论怎么排布都好，最终会被 FTL 均匀分摊到物理地址上去。

为了避免高强度读写同一块区域带来的磨损，FTL 会定期对数据进行搬移和重映射。

FTL 层可以解决固定位置的「Super Block」问题。

#### 递归更新问题

在我们更新一个文件时，有较大可能需要同时更新 `inode` 及其对应的 Block，同时还要更新 Block 空余表。就算只修改一点数据，都会放大带来很多块区域的修改。

#### 顺序写入

没有利用好 Flash 设备的高并行性。

#### NAT

这可以解决「递归更新」问题。直接使用 node 地址转换表，给出一个 node 号就可以拿到一个逻辑块。

用 NAT（Node Address Table）就可以查到一个块；块又分为「数据块」、「直接块」、「间接块」。

这样的修改就只会传递到 node 结构上。